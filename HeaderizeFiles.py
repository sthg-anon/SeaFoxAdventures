# Copyright (c) 2025 sthg-anon
# 
# This software is provided 'as-is', without any express or implied
# warranty. In no event will the authors be held liable for any damages
# arising from the use of this software.
# 
# Permission is granted to anyone to use this software for any purpose,
# including commercial applications, and to alter it and redistribute it
# freely, subject to the following restrictions:
# 
# 1. The origin of this software must not be misrepresented; you must not
#    claim that you wrote the original software. If you use this software
#    in a product, an acknowledgment in the product documentation would be
#    appreciated but is not required.
# 2. Altered source versions must be plainly marked as such, and must not be
#    misrepresented as being the original software.
# 3. This notice may not be removed or altered from any source distribution.

# This script takes in an files and turns each into a
# header and source file with a static byte array with
# that file data.

import os

SOURCE_PREAMBLE = """/** This file is auto generated by headerize_files.py! **/\n"""
NAMESPACE = "sfa"
BYTES_PER_LINE = 12
SOURCE_ASSET_DIR = "src/assets"
HEADER_ASSET_DIR = "include/assets"

def headerize_file(input_file: str, output_file: str, var_name: str):
    os.makedirs(os.path.dirname(f"{HEADER_ASSET_DIR}/{output_file}.hpp"), exist_ok=True)
    os.makedirs(os.path.dirname(f"{SOURCE_ASSET_DIR}/{output_file}.cpp"), exist_ok=True)
    with open(input_file, "rb") as f:
        data = f.read()

        if len(data) == 0:
            print(f"{input_file} is empty!")
            return
        
        with open(f"{HEADER_ASSET_DIR}/{output_file}.hpp", "w") as output:
            output.write(SOURCE_PREAMBLE)
            output.write("#pragma once\n")
            output.write("#include <cstdint>\n")
            output.write("#include <cstddef>\n")
            output.write(f"namespace {NAMESPACE}")
            output.write(" {\n")
            output.write(f"    extern const std::uint8_t {var_name}[];\n")
            output.write(f"    extern const std::size_t {var_name}_size;\n")
            output.write("}\n")
        
        with open(f"{SOURCE_ASSET_DIR}/{output_file}.cpp", "w") as output:
            output.write(SOURCE_PREAMBLE)
            output.write(f"#include \"assets/{output_file}.hpp\"\n")
            output.write(f"namespace {NAMESPACE}")
            output.write(" {\n")
            output.write(f"    const std::uint8_t {var_name}[] = ")
            output.write("{\n")

            for i in range(0, len(data), BYTES_PER_LINE):
                chunk = data[i:i+BYTES_PER_LINE]
                hexes = ", ".join(f"0x{b:02X}" for b in chunk)
                output.write(f"        {hexes},\n")
            output.write("    };\n")
            
            output.write(f"    const std::size_t {var_name}_size = sizeof({var_name});\n")

            output.write("}\n")

if __name__ == '__main__':
    headerize_file("assets/sprites/Tiles.png", "sprites/Tiles", "TilesSprite")
    headerize_file("assets/sprites/Player.png", "sprites/Player", "PlayerSprite")